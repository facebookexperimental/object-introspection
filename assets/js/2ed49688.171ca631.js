"use strict";(self.webpackChunkoi_web=self.webpackChunkoi_web||[]).push([[157],{6628:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=n(4848),s=n(8453);const o={title:"this pointers"},a=void 0,c={id:"addrbook-this",title:"this pointers",description:"We specify exactly which function and arguments are to be introspected through a probe specification (terminology borrowed from DTrace). It's simply a colon delimited tuple that specifies exactly what object we are interested in and where in the code we want to observe it. For example, to introspect the AddressBook object we can measure it at the entry to its DumpContacts() method and the specification would be:",source:"@site/docs/addrbook-this.md",sourceDirName:".",slug:"/addrbook-this",permalink:"/docs/addrbook-this",draft:!1,unlisted:!1,editUrl:"https://github.com/facebookexperimental/object-introspection/docs/addrbook-this.md",tags:[],version:"current",frontMatter:{title:"this pointers"},sidebar:"mysidebar",previous:{title:"A Simple Address Book Example",permalink:"/docs/addrbook-intro"},next:{title:"Function Arguments",permalink:"/docs/addrbook-funcargs"}},r={},d=[];function h(e){const t={a:"a",code:"code",em:"em",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["We specify exactly which function and arguments are to be introspected through a ",(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:"probe specification"})})," (terminology borrowed from ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/DTrace",children:"DTrace"}),"). It's simply a colon delimited tuple that specifies exactly what object we are interested in and where in the code we want to observe it. For example, to introspect the ",(0,i.jsx)(t.code,{children:"AddressBook"})," object we can measure it at the entry to its ",(0,i.jsx)(t.code,{children:"DumpContacts()"})," method and the specification would be:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"    entry:_ZN11AddressBook12DumpContactsEv:this\n"})}),"\n",(0,i.jsx)(t.p,{children:"There are a few points to note here:"}),"\n",(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["We are using the ",(0,i.jsx)("code",{children:"AddressBook::DumpContacts"})," method. Note that we specify the function name using the mangled C++ name which can be found using ",(0,i.jsx)("code",{children:"readelf -sW /path/to/binary | grep symbol"}),"."]}),(0,i.jsxs)("li",{children:["We are introspecting the object itself through the ",(0,i.jsx)("code",{children:"this"})," specifier."]}),(0,i.jsxs)("li",{children:["We are introspecting on entry to the method but we could have chosen to introspect the object the object at the return point from the ",(0,i.jsx)("code",{children:"AddressBook::DumpContacts()"})," method which would be useful if state had been altered during execution of he method."]})]}),"\n",(0,i.jsxs)(t.p,{children:["We use the ",(0,i.jsx)(t.code,{children:"oid"})," debugger to capture the object itself from the address book application. Every second a contact is added to the address book with the ",(0,i.jsx)(t.code,{children:"AddContact()"})," method and the address book is dumped with the ",(0,i.jsx)(t.code,{children:"DumpContacts()"})," method. After running for a minute or so let's capture the Address book object:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ build/oid -S 'entry:_ZN11AddressBook12DumpContactsEv:this' -p `pgrep addrbook` -c build/oid-cfg.toml -J\nAttached to pid 4039830\nSUCCESS\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"-J"})," flag instructed ",(0,i.jsx)(t.code,{children:"oid"})," to dump the captured objects introspection data in a JSON file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"$ ~/object-introspection# ls -l oid_out.json\n-rw-r--r-- 1 root root 78975 Dec 16 20:35 oid_out.json\n"})}),"\n",(0,i.jsx)(t.p,{children:"This is a simple object but the resulting JSON becomes quite large when more than a handful of contacts have been added. Let's examine some sections to see what we can glean about the object that has been captured:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'$ jq . oid_out.json\n[\n  {\n    "name": "this",\n    "typePath": "this",\n    "typeName": "AddressBook",\n    "isTypedef": false,\n    "staticSize": 64,\n    "dynamicSize": 23185,\n    "paddingSavingsSize": 4,\n    "members": [\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The root type is an ",(0,i.jsx)("code",{children:"AddressBook"})," object as we'd expect and it has a static footprint of 64 bytes with its data members in total having a dynamic memory footprint of 23185 bytes."]}),"\n",(0,i.jsxs)(t.p,{children:["The first member is simply an integer for the ",(0,i.jsx)("code",{children:"rev"})," data member which has a 4 byte static memory footprint on this platform."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'    "members": [\n      {\n        "name": "rev",\n        "typePath": "rev",\n        "typeName": "int",\n        "isTypedef": false,\n        "staticSize": 4,\n        "dynamicSize": 0\n      },\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Next we have a ",(0,i.jsx)("code",{children:"std::string"})," object for the top level ",(0,i.jsx)("code",{children:"Owner"})," member. Note how this is expanded down to the base types which show the string has a static footprint of 32 bytes but we can see that it is empty as it has a ",(0,i.jsx)("code",{children:"dynamicSize"})," of 0. The ",(0,i.jsx)("code",{children:"capacity"})," of 15 bytes shows the Short String optimization buffer in a libstdc++ ",(0,i.jsx)("code",{children:"std::string"})," object."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'      {\n        "name": "Owner",\n        "typePath": "Owner",\n        "typeName": "string",\n        "isTypedef": true,\n        "staticSize": 32,\n        "dynamicSize": 0,\n        "members": [\n          {\n            "name": "",\n            "typePath": "",\n            "typeName": "basic_string<char, std::char_traits<char>, std::alloca\ntor<char> >",\n            "isTypedef": false,\n            "staticSize": 32,\n            "dynamicSize": 0,\n            "length": 0,\n            "capacity": 15,\n            "elementStaticSize": 1\n          }\n        ]\n      },\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)("code",{children:"Entries"})," member gets a bit more interesting as it introduces usage of a C++ container class, the ",(0,i.jsx)("code",{children:"std::vector"}),". More accurately, it is a vector of ",(0,i.jsx)("code",{children:"Contact"})," objects as can be seen in the ",(0,i.jsx)("code",{children:"typeName"})," JSON member for the root of the ",(0,i.jsx)("code",{children:"Entries"})," object shown below. Note that the vector currently has an allocated ",(0,i.jsx)("code",{children:"capacity"})," of 128 ",(0,i.jsx)("code",{children:"Contact"})," elements of which 71 are actual ",(0,i.jsx)("code",{children:"Contact"})," objects. The 23185 bytes of dynamically allocated objects in the vector is composed of the 71 x 96 byte ",(0,i.jsx)("code",{children:"Contact"})," objects plus whatever memory that has been dynamically allocated for string content in those objects:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'      {\n        "name": "Entries",\n        "typePath": "Entries",\n        "typeName": "vector<Contact, std::allocator<Contact> >",\n        "isTypedef": false,\n        "staticSize": 24,\n        "dynamicSize": 23185,\n        "pointer": 140720550450568,\n        "length": 71,\n        "capacity": 128,\n        "elementStaticSize": 96,\n'})}),"\n",(0,i.jsxs)(t.p,{children:["For the sake of brevity let's just inspect the first ",(0,i.jsx)(t.code,{children:"Contact"})," object shown below. It's static footprint at 96 bytes is the three strings at 32 bytes each. We can see that the first and third string have strings larger than the 15 bytes allocated for the short string optimization buffer and are therefore allocated in dynamic memory that is external to the string objects themselves. The second string has no dynamic memory allocated as the 14 byte character sequence it is housing fits within the 15 byte pre-allocated buffer:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'\n        "members": [\n          {\n            "name": "",\n            "typePath": "Contact[]",\n            "typeName": "Contact",\n            "isTypedef": false,\n            "staticSize": 96,\n            "dynamicSize": 65,\n            "members": [\n              {\n                "name": "firstName",\n                "typePath": "firstName",\n                "typeName": "string",\n                "isTypedef": true,\n                "staticSize": 32,\n                "dynamicSize": 35,\n                "members": [\n                  {\n                    "name": "",\n                    "typePath": "",\n                    "typeName": "basic_string<char, std::char_traits<char>, std::allocator<char> >",\n                    "isTypedef": false,\n                    "staticSize": 32,\n                    "dynamicSize": 35,\n                    "length": 35,\n                    "capacity": 35,\n                    "elementStaticSize": 1\n                  }\n                ]\n              },\n              {\n                "name": "lastName",\n                "typePath": "lastName",\n                "typeName": "string",\n                "isTypedef": true,\n                "staticSize": 32,\n                "dynamicSize": 0,\n                "members": [\n                  {\n                    "name": "",\n                    "typePath": "",\n                    "typeName": "basic_string<char, std::char_traits<char>, std::allocator<char> >",\n                    "isTypedef": false,\n                    "staticSize": 32,\n                    "dynamicSize": 0,\n                    "length": 14,\n                    "capacity": 15,\n                    "elementStaticSize": 1\n                  }\n                ]\n              },\n              {\n                "name": "number",\n                "typePath": "number",\n                "typeName": "string",\n                "isTypedef": true,\n                "staticSize": 32,\n                "dynamicSize": 30,\n                "members": [\n                  {\n                    "name": "",\n                    "typePath": "",\n                    "typeName": "basic_string<char, std::char_traits<char>, std::allocator<char> >",\n                    "isTypedef": false,\n                    "staticSize": 32,\n                    "dynamicSize": 30,\n                    "length": 18,\n                    "capacity": 30,\n                    "elementStaticSize": 1\n                  }\n                ]\n              }\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In total we have 71 ",(0,i.jsx)(t.code,{children:"Contact"})," objects introspected here and each can be analyzed as we have done above:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'$ ~/object-introspection# jq . /tmp/oit.oit.json.fmt | grep -c "\\"typeName\\": \\"Contact\\""\n71\n'})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var i=n(6540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);