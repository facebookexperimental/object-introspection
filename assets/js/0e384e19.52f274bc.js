"use strict";(self.webpackChunkoi_web=self.webpackChunkoi_web||[]).push([[976],{619:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var n=o(4848),i=o(8453);const r={sidebar_position:1},s="Introduction",c={id:"intro",title:"Introduction",description:"Object Introspection (shortened to OI and pronounced as in boy) is a memory profiling technology for C++ objects. It provides the ability to dynamically instrument applications to capture the precise memory occupancy of entire object hierarchies including all containers and dynamic allocations. All this with no code modification or recompilation!",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,unlisted:!1,editUrl:"https://github.com/facebookexperimental/object-introspection/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"mysidebar",next:{title:"Getting Started",permalink:"/docs/getting-started"}},a={},d=[{value:"How does it do this?",id:"how-does-it-do-this",level:2}];function h(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,n.jsxs)(t.p,{children:["Object Introspection (shortened to ",(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"OI"})})," and pronounced as in ",(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"boy"})}),") is a memory profiling technology for C++ objects. It provides the ability to dynamically instrument applications to capture the precise memory occupancy of entire object hierarchies including all containers and dynamic allocations. All this with no code modification or recompilation!"]}),"\n",(0,n.jsx)(t.h2,{id:"how-does-it-do-this",children:"How does it do this?"}),"\n",(0,n.jsxs)(t.p,{children:["In lieu of more detailed documentation (outside of the code obviously!) here is a brief description of the OI technology. There is a core technology and two different flavors of how it can actually be consumed: a hands-off classic debugger style technology that controls a target process called ",(0,n.jsx)("code",{children:"oid"})," and an API called ",(0,n.jsx)("code",{children:"OIL"})," that provides programmatic object introspection."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Type reconstruction:"})})," A C++ object is described in detail by the debug data generated generated by a compiler (the ",(0,n.jsx)("code",{children:"-g"})," flag with the clang and gcc compiler toolchains) and OI consumes DWARF debug data to reconstruct types from a generated binary. Given a known root type we fully reconstruct the entire type hierarchy including all the descendant types - think of an object as a tree of types that is rooted at a known base type."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Code Generation:"})})," We then iterate over the type tree to auto-generate C++ code to perform operations on each node on the tree. For example, if we have a ",(0,n.jsx)("code",{children:"std::vector"})," of ",(0,n.jsx)("code",{children:"std::string"})," objects then we know that a vector has an iterator and a strings dynamic size can be measured with it's ",(0,n.jsx)("code",{children:"size()"})," method (individual containers have space optimization schemes such as Short String Optimization for strings which we take into account)."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"JIT Compilation:"})})," The auto-generated C++ code is then JIT compiled into x86-64 object code. Depending upon how we are using OI technology this object code is then relocated for the address space of a target process (",(0,n.jsx)("code",{children:"oid"}),") or it is ready to be executed directly (",(0,n.jsx)("code",{children:"OIL"}),")."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Dynamic Instrumentation:"})})," The generated object code is copied into a dedicated text segment in the target process ready for execution. Standard text modification techniques are employed to hijack threads at specific points in program execution - these locations are specified by the user. The hijacked thread is then redirected to execute the object code for a specific object. Introspection results are written to a dedicated text segment in the target process during execution of the introspection code."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.em,{children:(0,n.jsx)(t.strong,{children:"Object Processing:"})})," Data generated from the object introspection process is then copied out of the target address space by the ",(0,n.jsx)("code",{children:"oid"})," debugger and processed. This includes reconstructing the entire object tree for the captured data and attributing results correctly."]}),"\n",(0,n.jsxs)(t.p,{children:["The above is a very high level view of the basic implementation but there are many more aspects which we hope you'll be interested in. Please bear in mind that this is very much a work-in-progress and the initial design and implementation fits the specific needs of Meta. Our experience is that OI has opened up many new and exciting ways of viewing our application memory footprints in live applications and we hope it can do the same for you. However, please check out the current ",(0,n.jsx)(t.a,{href:"/docs/constraints",children:"constraints"})," to see whether you can make use of OI currently and please let us know of your requirements if not (please feel free to contribute!)."]})]})}function l(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>c});var n=o(6540);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);